<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haji Ali Traders - Waste Sorting</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    
    <!-- Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    
    <style>
        /* === VIBRANT ECO-GREEN THEME (100% unchanged) === */
        :root {
            --primary-green: #27ae60;
            --dark-green: #219653;
            --light-green: #d4edda;
            --vibrant-green: #2ecc71;
            --accent-teal: #1abc9c;
            --background: #f8f9fa;
            --card-bg: #ffffff;
            --text-dark: #2c3e50;
            --text-light: #7f8c8d;
            --border: #dfe6e9;
            --pending: #f39c12;
            --finished: #3498db;
            --error: #e74c3c;
            --warning: #f1c40f;
        }
        
        /* === BASE STYLES === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, var(--background) 0%, #e8f5e9 100%);
            color: var(--text-dark);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 100%;
            min-height: 100vh;
            padding: 0;
        }
        
        /* === HEADER === */
        .app-header {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--dark-green) 100%);
            color: white;
            padding: 20px 15px;
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .app-title h1 {
            font-size: 1.4rem;
            margin-bottom: 3px;
            font-weight: 700;
        }
        
        .app-title p {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        
        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            padding: 8px 12px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
        }
        
        .sync-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #2ecc71;
            animation: pulse 2s infinite;
        }
        
        .sync-dot.offline {
            background: #e74c3c;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* === TABS (unchanged) === */
        .tabs-container {
            background: white;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            padding: 0 15px;
        }
        
        .tabs {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .tab {
            flex: 1;
            padding: 18px 10px;
            text-align: center;
            font-weight: 600;
            color: var(--text-light);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            position: relative;
        }
        
        .tab:hover {
            background: var(--light-green);
        }
        
        .tab.active {
            color: var(--primary-green);
            border-bottom-color: var(--primary-green);
            background: linear-gradient(to top, var(--light-green), transparent);
        }
        
        .tab-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--vibrant-green);
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
        }
        
        /* === MAIN CONTENT === */
        .app-content {
            padding: 15px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* === CARDS === */
        .card {
            background: var(--card-bg);
            border-radius: 18px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            border: 1px solid var(--border);
        }
        
        .card-title {
            font-size: 1.2rem;
            color: var(--text-dark);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            color: var(--primary-green);
        }
        
        /* === BUTTON GRIDS === */
        .button-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        @media (max-width: 480px) {
            .button-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .backup-button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .backup-button-grid {
                grid-template-columns: repeat(1, 1fr);
            }
        }
        
        .grid-btn {
            padding: 18px 10px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--background);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: var(--text-dark);
        }
        
        .grid-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .grid-btn.selected {
            border-color: var(--primary-green);
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--accent-teal) 100%);
            color: white;
            box-shadow: 0 6px 15px rgba(39, 174, 96, 0.3);
        }
        
        .add-btn {
            border-style: dashed;
            border-color: var(--accent-teal);
            color: var(--accent-teal);
            background: rgba(26, 188, 156, 0.1);
        }
        
        .add-btn:hover {
            background: var(--accent-teal);
            color: white;
        }
        
        /* === INPUTS === */
        .input-group {
            margin: 25px 0;
        }
        
        .input-label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            color: var(--text-dark);
            font-size: 1.1rem;
        }
        
        .weight-input {
            width: 100%;
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: 15px;
            font-size: 1.3rem;
            font-weight: 700;
            text-align: center;
            background: var(--background);
            color: var(--text-dark);
            transition: all 0.3s;
        }
        
        .weight-input:focus {
            border-color: var(--primary-green);
            outline: none;
            box-shadow: 0 0 0 4px rgba(39, 174, 96, 0.1);
            background: white;
        }
        
        /* === STATUS BUTTONS === */
        .status-buttons {
            display: flex;
            gap: 15px;
            margin: 30px 0;
        }
        
        .status-btn {
            flex: 1;
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: 15px;
            background: var(--background);
            font-weight: 700;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .status-btn:hover {
            transform: translateY(-2px);
        }
        
        .status-btn.selected {
            border-color: var(--primary-green);
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--dark-green) 100%);
            color: white;
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }
        
        /* === ACTION BUTTONS === */
        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }
        
        .action-btn {
            flex: 1;
            padding: 20px;
            border: none;
            border-radius: 15px;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .btn-clear {
            background: var(--background);
            color: var(--text-light);
        }
        
        .btn-clear:hover {
            background: #e9ecef;
        }
        
        .btn-save {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--accent-teal) 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }
        
        .btn-save:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(39, 174, 96, 0.5);
        }
        
        /* === STATS GRID === */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 25px 0;
        }
        
        @media (max-width: 600px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .stat-box {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--accent-teal) 100%);
            padding: 25px 20px;
            border-radius: 15px;
            text-align: center;
            color: white;
            box-shadow: 0 8px 20px rgba(39, 174, 96, 0.3);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            display: block;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        
        /* === BATCH CARDS === */
        .batch-list {
            margin-top: 20px;
        }
        
        .batch-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 5px solid var(--primary-green);
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            transition: all 0.3s;
            border: 1px solid var(--border);
        }
        
        .batch-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .batch-card.pending {
            border-left-color: var(--pending);
        }
        
        .batch-card.finished {
            border-left-color: var(--finished);
        }
        
        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .batch-title {
            font-weight: 700;
            font-size: 1.2rem;
            color: var(--text-dark);
        }
        
        .batch-weight {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--accent-teal) 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 1.1rem;
            min-width: 100px;
            text-align: center;
        }
        
        .batch-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 15px;
        }
        
        .batch-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .action-small {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .btn-edit {
            background: var(--light-green);
            color: var(--primary-green);
        }
        
        .btn-edit:hover {
            background: var(--primary-green);
            color: white;
        }
        
        .btn-finish {
            background: linear-gradient(135deg, var(--finished) 0%, #2980b9 100%);
            color: white;
        }
        
        .btn-finish:hover {
            opacity: 0.9;
        }
        
        .btn-move {
            background: var(--accent-teal);
            color: white;
        }
        
        .btn-move:hover {
            background: #16a085;
        }
        
        /* === MODALS === */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
            animation: fadeIn 0.3s;
        }
        
        .modal {
            background: white;
            border-radius: 20px;
            width: 100%;
            max-width: 500px;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            animation: slideUp 0.4s;
        }
        
        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-header {
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--dark-green) 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        .modal-header h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .modal-body {
            padding: 30px;
        }
        
        .modal-input {
            width: 100%;
            padding: 18px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        
        .modal-input:focus {
            border-color: var(--primary-green);
            outline: none;
        }
        
        .modal-actions {
            display: flex;
            gap: 15px;
        }
        
        .modal-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn-cancel {
            background: var(--background);
            color: var(--text-light);
        }
        
        .btn-submit {
            background: var(--primary-green);
            color: white;
        }
        
        /* === NOTIFICATION === */
        .notification {
            position: fixed;
            bottom: 25px;
            right: 25px;
            background: linear-gradient(135deg, var(--primary-green) 0%, var(--dark-green) 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(39, 174, 96, 0.4);
            display: none;
            z-index: 1001;
            animation: slideInRight 0.3s;
            max-width: 400px;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0%); opacity: 1; }
        }
        
        .notification.error {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        /* === EMPTY STATE === */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-light);
        }
        
        .empty-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        
        /* === COLOR INDICATORS === */
        .color-dot {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* === LOADING === */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 50px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--light-green);
            border-top: 4px solid var(--primary-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* === FOOTER === */
        .app-footer {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
            font-size: 0.85rem;
            margin-top: 30px;
        }
        
        /* === LOGIN SYSTEM === */
        .login-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .login-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--primary-green);
        }
        
        .logout-btn {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .logout-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .auth-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .auth-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .view-only-message {
            background: var(--light-green);
            border: 2px solid var(--primary-green);
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            color: var(--dark-green);
        }
        
        .view-only-message i {
            font-size: 1.2rem;
            margin-right: 8px;
        }
        
        .disabled-for-view {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .login-prompt {
            background: linear-gradient(135deg, var(--warning) 0%, #e67e22 100%);
            padding: 15px;
            border-radius: 12px;
            color: white;
            text-align: center;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .login-prompt:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(243, 156, 18, 0.3);
        }
        
        /* === Export Options === */
        .export-options {
            margin-top: 20px;
            padding: 20px;
            background: var(--light-green);
            border-radius: 15px;
        }
        
        .export-options h3 {
            color: var(--dark-green);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .export-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .export-btn {
            flex: 1;
            min-width: 140px;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .btn-pdf {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border-color: #e74c3c;
        }
        
        .btn-excel {
            background: linear-gradient(135deg, #27ae60 0%, #219653 100%);
            color: white;
            border-color: #27ae60;
        }
        
        .btn-summary {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border-color: #3498db;
        }
        
        .btn-details {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
            border-color: #9b59b6;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <div class="logo-section">
                    <div class="app-title">
                        <h1>Haji Ali Traders</h1>
                        <p>Waste Sorting & Inventory Management</p>
                    </div>
                </div>
                
                <div class="login-info">
                    <!-- Login status will appear here when logged in -->
                    <div class="login-status" id="loginStatus" style="display: none;">
                        <div class="user-avatar" id="userAvatar">üë§</div>
                        <span id="userMobile"></span>
                        <button class="logout-btn" id="logoutBtn" title="Logout">üö™</button>
                    </div>
                    
                    <!-- Login button for non-logged users -->
                    <button class="auth-btn" id="loginBtn">
                        üîí Login to Edit
                    </button>
                    
                    <div class="sync-status" id="syncStatus">
                        <div class="sync-dot" id="syncDot"></div>
                        <span id="syncText">Synced</span>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Tabs -->
        <div class="tabs-container">
            <div class="tabs">
                <div class="tab active" data-tab="add">
                    ‚ûï Add Entry
                    <span class="tab-badge" id="addBadge" style="display: none;">0</span>
                </div>
                <div class="tab" data-tab="pending">
                    ‚è≥ Pending Stock
                    <span class="tab-badge" id="pendingBadge">0</span>
                </div>
                <div class="tab" data-tab="finished">
                    ‚úÖ Finished
                    <span class="tab-badge" id="finishedBadge">0</span>
                </div>
                <div class="tab" data-tab="backup">
                    üíæ Backup & Export
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <main class="app-content">
            <!-- View-Only Message (shown when not logged in) -->
            <div id="viewOnlyMessage" class="view-only-message" style="display: none;">
                <div>
                    <span>üëÅÔ∏è <strong>View Only Mode</strong></span>
                    <p style="margin-top: 8px; font-size: 0.9rem;">
                        Login with mobile number to edit, add, or delete data
                    </p>
                    <button class="auth-btn" onclick="showLoginModal()" style="margin-top: 10px; color: var(--dark-green); background: white; border-color: white;">
                        üîí Login to Edit
                    </button>
                </div>
            </div>
            
            <!-- Add Entry Tab -->
            <div class="tab-content active" id="add">
                <!-- Material Selection -->
                <div class="card">
                    <h2 class="card-title">
                        <span>üéØ</span> Select Material
                    </h2>
                    <div class="button-grid" id="materialGrid">
                        <!-- Materials loaded dynamically -->
                    </div>
                    <button class="grid-btn add-btn" id="addMaterialBtn">
                        <span>‚ûï</span> Add New Material
                    </button>
                </div>
                
                <!-- Colour Selection -->
                <div class="card">
                    <h2 class="card-title">
                        <span>üé®</span> Select Colour
                    </h2>
                    <div class="button-grid" id="colourGrid">
                        <!-- Colours loaded dynamically -->
                    </div>
                    <button class="grid-btn add-btn" id="addColourBtn">
                        <span>‚ûï</span> Add New Colour
                    </button>
                </div>
                
                <!-- Weight & Status -->
                <div class="card">
                    <div class="input-group">
                        <label class="input-label">‚öñÔ∏è Weight (kg)</label>
                        <input type="number" class="weight-input" id="weight" 
                               step="0.1" min="0.1" placeholder="Enter weight in kilograms">
                    </div>
                    
                    <div class="status-buttons">
                        <div class="status-btn selected" data-status="pending">
                            <span>‚è≥</span> Pending Stock
                        </div>
                        <div class="status-btn" data-status="finished">
                            <span>‚úÖ</span> Finished Batch
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="action-btn btn-clear" id="clearBtn">
                            <span>üóëÔ∏è</span> Clear Form
                        </button>
                        <button class="action-btn btn-save" id="saveBtn">
                            <span>üíæ</span> Save Entry
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Pending Stock Tab -->
            <div class="tab-content" id="pending">
                <div class="card">
                    <div class="stats-grid">
                        <div class="stat-box">
                            <span class="stat-value" id="pendingTotalWeight">0</span>
                            <span class="stat-label">Total Pending (kg)</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="pendingBatchesCount">0</span>
                            <span class="stat-label">Active Batches</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="pendingItemsCount">0</span>
                            <span class="stat-label">Total Entries</span>
                        </div>
                    </div>
                    
                    <div class="batch-list" id="pendingList">
                        <div class="loading">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Finished Tab -->
            <div class="tab-content" id="finished">
                <div class="card">
                    <div class="stats-grid">
                        <div class="stat-box">
                            <span class="stat-value" id="finishedTotalWeight">0</span>
                            <span class="stat-label">Total Finished (kg)</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="finishedBatchesCount">0</span>
                            <span class="stat-label">Completed Batches</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="finishedItemsCount">0</span>
                            <span class="stat-label">Total Entries</span>
                        </div>
                    </div>
                    
                    <div class="batch-list" id="finishedList">
                        <div class="loading">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Backup & Export Tab -->
            <div class="tab-content" id="backup">
                <div class="card">
                    <!-- NEW: Stats now show Pending and Finished separately -->
                    <div class="stats-grid">
                        <div class="stat-box">
                            <span class="stat-value" id="pendingBackupStats">0</span>
                            <span class="stat-label">Pending Batches (kg)</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="finishedBackupStats">0</span>
                            <span class="stat-label">Finished Batches (kg)</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="totalBackupStats">0</span>
                            <span class="stat-label">Entries | Storage | Sync</span>
                        </div>
                    </div>
                    
                    <!-- Export Section -->
                    <div class="export-options">
                        <h3>üì§ Export Reports</h3>
                        <div class="export-buttons">
                            <button class="export-btn btn-pdf" id="exportPdfBtn">
                                üìÑ PDF Summary
                            </button>
                            <button class="export-btn btn-excel" id="exportExcelBtn">
                                üìä Excel Full Data
                            </button>
                            <button class="export-btn btn-summary" id="exportSummaryBtn">
                                üìà Stats Report
                            </button>
                            <button class="export-btn btn-details" id="exportDetailsBtn">
                                üìã Detailed Report
                            </button>
                        </div>
                    </div>
                    
                    <div class="backup-button-grid">
                        <button class="grid-btn" id="exportBtn" style="background: var(--finished); color: white;">
                            <span>‚¨áÔ∏è</span> Export JSON Backup
                        </button>
                        <button class="grid-btn" id="importBtn" style="background: var(--accent-teal); color: white;">
                            <span>‚¨ÜÔ∏è</span> Import JSON Backup
                        </button>
                        <button class="grid-btn" id="clearAllBtn" style="background: var(--error); color: white;">
                            <span>üóëÔ∏è</span> Clear All Data
                        </button>
                    </div>
                    
                    <!-- Separate Clear Pending & Clear Finished Buttons -->
                    <div style="margin-top: 20px;">
                        <h3 style="color: var(--dark-green); margin-bottom: 15px;">üßπ Clear Data</h3>
                        <div class="backup-button-grid">
                            <button class="grid-btn" id="clearPendingBtn" style="background: var(--warning); color: white;">
                                <span>‚è≥</span> Clear Pending Batches
                            </button>
                            <button class="grid-btn" id="clearFinishedBtn" style="background: var(--finished); color: white;">
                                <span>‚úÖ</span> Clear Finished Batches
                            </button>
                        </div>
                    </div>
                    
                    <div style="padding: 20px; background: var(--light-green); border-radius: 15px; margin-top: 20px;">
                        <h3 style="color: var(--dark-green); margin-bottom: 10px;">üì± About This App</h3>
                        <p style="color: var(--text-light); font-size: 0.9rem;">
                            ‚Ä¢ Data saved locally and synced to cloud<br>
                            ‚Ä¢ Works completely offline<br>
                            ‚Ä¢ Real-time updates across all devices<br>
                            ‚Ä¢ Export reports in PDF & Excel formats<br>
                            ‚Ä¢ Add new colours/materials as needed
                        </p>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="app-footer">
            <p>Haji Ali Traders ¬© 2023 ‚Ä¢ Waste Management System v1.0</p>
        </footer>
        
        <!-- Modals -->
        <!-- Add Material Modal -->
        <div class="modal-overlay" id="materialModal">
            <div class="modal">
                <div class="modal-header">
                    <h2>‚ûï Add New Material</h2>
                    <p>Add a new material type to the list</p>
                </div>
                <div class="modal-body">
                    <input type="text" class="modal-input" id="newMaterialInput" 
                           placeholder="Enter material name (e.g., Silk, Linen)">
                    <div class="modal-actions">
                        <button class="modal-btn btn-cancel" id="cancelMaterialBtn">Cancel</button>
                        <button class="modal-btn btn-submit" id="saveMaterialBtn">Add Material</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Add Colour Modal -->
        <div class="modal-overlay" id="colourModal">
            <div class="modal">
                <div class="modal-header">
                    <h2>üé® Add New Colour</h2>
                    <p>Add a new colour to the list</p>
                </div>
                <div class="modal-body">
                    <input type="text" class="modal-input" id="newColourInput" 
                           placeholder="Enter colour name (e.g., Navy Blue, Peach)">
                    <div class="modal-actions">
                        <button class="modal-btn btn-cancel" id="cancelColourBtn">Cancel</button>
                        <button class="modal-btn btn-submit" id="saveColourBtn">Add Colour</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Edit Weight Modal -->
        <div class="modal-overlay" id="editWeightModal">
            <div class="modal">
                <div class="modal-header">
                    <h2>‚öñÔ∏è Edit Batch Weight</h2>
                    <p id="editBatchTitle">Adjust the total weight</p>
                </div>
                <div class="modal-body">
                    <input type="number" class="modal-input" id="editWeightInput" 
                           step="0.1" min="0.1" placeholder="Enter new weight">
                    <div class="modal-actions">
                        <button class="modal-btn btn-cancel" id="cancelEditBtn">Cancel</button>
                        <button class="modal-btn btn-submit" id="saveEditBtn">Update Weight</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Move Weight Modal -->
        <div class="modal-overlay" id="moveWeightModal">
            <div class="modal">
                <div class="modal-header">
                    <h2>‚û°Ô∏è Move to Finished</h2>
                    <p id="moveBatchTitle">Enter weight to move from pending to finished</p>
                </div>
                <div class="modal-body">
                    <input type="number" class="modal-input" id="moveWeightInput" 
                           step="0.1" min="0.1" placeholder="Weight to move (kg)">
                    <div class="modal-actions">
                        <button class="modal-btn btn-cancel" id="cancelMoveBtn">Cancel</button>
                        <button class="modal-btn btn-submit" id="saveMoveBtn">Move Weight</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Login Modal -->
        <div class="modal-overlay" id="loginModal">
            <div class="modal">
                <div class="modal-header">
                    <h2>üîí Login Required</h2>
                    <p>Enter mobile number to access edit features</p>
                </div>
                <div class="modal-body">
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">üì± Mobile Number</label>
                        <input type="tel" class="modal-input" id="mobileNumber" 
                               placeholder="Enter 10-digit mobile number" maxlength="10">
                    </div>
                    
                    <div class="modal-actions">
                        <button class="modal-btn btn-cancel" id="cancelLoginBtn">Cancel</button>
                        <button class="modal-btn btn-submit" id="loginMobileBtn">Login</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Notification -->
        <div class="notification" id="notification">
            <span id="notificationText">Entry saved successfully!</span>
        </div>
    </div>

    <!-- Main App Script -->
    <script>
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyByCMBxi1YkvRZpiPELxZwXETcCI0EUwP0",
            authDomain: "haji-ali-traders-ed7cc.firebaseapp.com",
            projectId: "haji-ali-traders-ed7cc",
            storageBucket: "haji-ali-traders-ed7cc.firebasestorage.app",
            messagingSenderId: "746078974269",
            appId: "1:746078974269:web:55c1f37a9a11c8b887d554"
        };
        
        // ============================================
        // APP CONFIGURATION
        // ============================================
        const APP_CONFIG = {
            appName: "Haji Ali Traders",
            version: "1.0.0",
            defaultMaterials: ["Cotton 1st", "Gaada", "Polyester", "Rising", "80/20", "Other"],
            defaultColours: ["Darga", "Orange", "Red", "Yellow", "Green", "White", "Mecko", 
                           "Bottle Green", "Maroon", "Apple Green", "Rani Rose", "Biscuit", 
                           "TC", "Grey", "Other"],
            firestoreCollections: {
                entries: "waste_entries",
                batches: "waste_batches",
                materials: "material_list",
                colours: "colour_list",
                settings: "app_settings"
            },
            authorizedMobile: "9370664141"
        };
        
        // ============================================
        // GLOBAL STATE
        // ============================================
        let appState = {
    selectedMaterial: null,
    selectedColour: null,
    selectedStatus: "pending",
    
    materials: [...APP_CONFIG.defaultMaterials],
    colours: [...APP_CONFIG.defaultColours],
    batches: [],
    entries: [],
    
    firebaseInitialized: false,
    db: null,
    unsubscribeFunctions: [],
    
    isOnline: navigator.onLine,
    lastSyncTime: null,
    pendingSync: [],
    
    editingBatch: null,
    movingBatch: null,
    
    isLoggedIn: false,
    user: null,
    _ignoreBatchSnapshot: false   // <-- added here, with a comma before it
};
        
        
        // ============================================
        // DOM ELEMENTS (with null safety)
        // ============================================
        function getElement(id) {
            return document.getElementById(id);
        }
        
        const elements = {
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            
            materialGrid: getElement('materialGrid'),
            colourGrid: getElement('colourGrid'),
            
            weightInput: getElement('weight'),
            
            addMaterialBtn: getElement('addMaterialBtn'),
            addColourBtn: getElement('addColourBtn'),
            clearBtn: getElement('clearBtn'),
            saveBtn: getElement('saveBtn'),
            exportBtn: getElement('exportBtn'),
            importBtn: getElement('importBtn'),
            clearAllBtn: getElement('clearAllBtn'),
            loginBtn: getElement('loginBtn'),
            logoutBtn: getElement('logoutBtn'),
            
            clearPendingBtn: getElement('clearPendingBtn'),
            clearFinishedBtn: getElement('clearFinishedBtn'),
            
            exportPdfBtn: getElement('exportPdfBtn'),
            exportExcelBtn: getElement('exportExcelBtn'),
            exportSummaryBtn: getElement('exportSummaryBtn'),
            exportDetailsBtn: getElement('exportDetailsBtn'),
            
            statusButtons: document.querySelectorAll('.status-btn'),
            
            materialModal: getElement('materialModal'),
            colourModal: getElement('colourModal'),
            editWeightModal: getElement('editWeightModal'),
            moveWeightModal: getElement('moveWeightModal'),
            loginModal: getElement('loginModal'),
            
            saveMaterialBtn: getElement('saveMaterialBtn'),
            cancelMaterialBtn: getElement('cancelMaterialBtn'),
            saveColourBtn: getElement('saveColourBtn'),
            cancelColourBtn: getElement('cancelColourBtn'),
            saveEditBtn: getElement('saveEditBtn'),
            cancelEditBtn: getElement('cancelEditBtn'),
            saveMoveBtn: getElement('saveMoveBtn'),
            cancelMoveBtn: getElement('cancelMoveBtn'),
            loginMobileBtn: getElement('loginMobileBtn'),
            cancelLoginBtn: getElement('cancelLoginBtn'),
            
            newMaterialInput: getElement('newMaterialInput'),
            newColourInput: getElement('newColourInput'),
            editWeightInput: getElement('editWeightInput'),
            editBatchTitle: getElement('editBatchTitle'),
            moveWeightInput: getElement('moveWeightInput'),
            moveBatchTitle: getElement('moveBatchTitle'),
            mobileNumber: getElement('mobileNumber'),
            
            pendingList: getElement('pendingList'),
            finishedList: getElement('finishedList'),
            
            pendingTotalWeight: getElement('pendingTotalWeight'),
            pendingBatchesCount: getElement('pendingBatchesCount'),
            pendingItemsCount: getElement('pendingItemsCount'),
            finishedTotalWeight: getElement('finishedTotalWeight'),
            finishedBatchesCount: getElement('finishedBatchesCount'),
            finishedItemsCount: getElement('finishedItemsCount'),
            
            // Backup tab new stat elements
            pendingBackupStats: getElement('pendingBackupStats'),
            finishedBackupStats: getElement('finishedBackupStats'),
            totalBackupStats: getElement('totalBackupStats'),
            
            badges: {
                add: getElement('addBadge'),
                pending: getElement('pendingBadge'),
                finished: getElement('finishedBadge')
            },
            
            syncDot: getElement('syncDot'),
            syncText: getElement('syncText'),
            syncStatus: getElement('syncStatus'),
            
            loginStatus: getElement('loginStatus'),
            userAvatar: getElement('userAvatar'),
            userMobile: getElement('userMobile'),
            
            notification: getElement('notification'),
            notificationText: getElement('notificationText'),
            
            viewOnlyMessage: getElement('viewOnlyMessage')
        };
        
        // ============================================
        // EXPORT FUNCTIONS ‚Äì NOW FULLY SEPARATE PENDING & FINISHED
        // ============================================
        function exportToPDF(type = 'summary') {
            if (!appState.isLoggedIn && type !== 'summary') {
                showNotification("Please login to export detailed data", "error");
                showLoginModal();
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            doc.setFontSize(20);
            doc.setTextColor(39, 174, 96);
            doc.text('Haji Ali Traders', 105, 20, { align: 'center' });
            doc.setFontSize(14);
            doc.setTextColor(128, 128, 128);
            doc.text('Waste Sorting & Inventory Report', 105, 28, { align: 'center' });
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, 105, 35, { align: 'center' });
            
            let yPos = 45;
            
            const pendingBatches = appState.batches.filter(b => b.status === 'pending');
            const finishedBatches = appState.batches.filter(b => b.status === 'finished');
            const pendingTotal = pendingBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            const finishedTotal = finishedBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            
            if (type === 'summary') {
                // === SEPARATE PENDING & FINISHED TABLES ===
                doc.setFontSize(16);
                doc.setTextColor(0, 0, 0);
                doc.text('Pending Batches', 20, yPos);
                yPos += 10;
                
                if (pendingBatches.length === 0) {
                    doc.setFontSize(12);
                    doc.text('No pending batches', 20, yPos);
                    yPos += 10;
                } else {
                    const pendingTableData = pendingBatches.map(b => [
                        b.colour, b.material, `${b.totalWeight.toFixed(1)} kg`, 
                        b.entries.length, new Date(b.lastUpdated).toLocaleDateString()
                    ]);
                    doc.autoTable({
                        startY: yPos,
                        head: [['Colour', 'Material', 'Weight', 'Entries', 'Last Updated']],
                        body: pendingTableData,
                        theme: 'grid',
                        headStyles: { fillColor: [243, 156, 18] } // pending orange
                    });
                    yPos = doc.lastAutoTable.finalY + 15;
                }
                
                doc.setFontSize(16);
                doc.text('Finished Batches', 20, yPos);
                yPos += 10;
                
                if (finishedBatches.length === 0) {
                    doc.setFontSize(12);
                    doc.text('No finished batches', 20, yPos);
                } else {
                    const finishedTableData = finishedBatches.map(b => [
                        b.colour, b.material, `${b.totalWeight.toFixed(1)} kg`, 
                        b.entries.length, new Date(b.lastUpdated).toLocaleDateString()
                    ]);
                    doc.autoTable({
                        startY: yPos,
                        head: [['Colour', 'Material', 'Weight', 'Entries', 'Last Updated']],
                        body: finishedTableData,
                        theme: 'grid',
                        headStyles: { fillColor: [52, 152, 219] } // finished blue
                    });
                }
                
                // Summary totals at bottom
                const finalY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : yPos + 20;
                doc.setFontSize(12);
                doc.text(`Total Pending: ${pendingBatches.length} batches / ${pendingTotal.toFixed(1)} kg`, 20, finalY);
                doc.text(`Total Finished: ${finishedBatches.length} batches / ${finishedTotal.toFixed(1)} kg`, 20, finalY + 7);
                doc.text(`Overall Total: ${appState.batches.length} batches / ${(pendingTotal+finishedTotal).toFixed(1)} kg`, 20, finalY + 14);
                
            } else if (type === 'details') {
                // Detailed report (grouped by material/colour) ‚Äì already separates pending/finished columns
                doc.setFontSize(16);
                doc.setTextColor(0, 0, 0);
                doc.text('Detailed Inventory Report', 20, yPos);
                yPos += 10;
                
                const groupedData = {};
                appState.batches.forEach(batch => {
                    const key = `${batch.material}-${batch.colour}`;
                    if (!groupedData[key]) {
                        groupedData[key] = {
                            material: batch.material,
                            colour: batch.colour,
                            pending: 0,
                            finished: 0,
                            total: 0
                        };
                    }
                    if (batch.status === 'pending') {
                        groupedData[key].pending += batch.totalWeight;
                    } else {
                        groupedData[key].finished += batch.totalWeight;
                    }
                    groupedData[key].total += batch.totalWeight;
                });
                
                const tableData = Object.values(groupedData).map(item => [
                    item.material, item.colour,
                    `${item.pending.toFixed(1)} kg`,
                    `${item.finished.toFixed(1)} kg`,
                    `${item.total.toFixed(1)} kg`
                ]);
                
                doc.autoTable({
                    startY: yPos,
                    head: [['Material', 'Colour', 'Pending (kg)', 'Finished (kg)', 'Total (kg)']],
                    body: tableData,
                    theme: 'grid',
                    headStyles: { fillColor: [39, 174, 96] }
                });
            }
            
            doc.save(`Haji_Ali_Traders_${type}_${new Date().toISOString().split('T')[0]}.pdf`);
            showNotification(`‚úÖ PDF exported successfully`);
        }
        
        function exportToExcel(type = 'full') {
            if (!appState.isLoggedIn) {
                showNotification("Please login to export Excel data", "error");
                showLoginModal();
                return;
            }
            
            let workbook = XLSX.utils.book_new();
            const pendingBatches = appState.batches.filter(b => b.status === 'pending');
            const finishedBatches = appState.batches.filter(b => b.status === 'finished');
            
            if (type === 'full' || type === 'details') {
                // === PENDING BATCHES SHEET ===
                const pendingData = pendingBatches.map(b => ({
                    'Batch ID': b.id,
                    'Colour': b.colour,
                    'Material': b.material,
                    'Total Weight (kg)': b.totalWeight,
                    'Entries': b.entries.length,
                    'Created': new Date(b.createdAt).toLocaleDateString(),
                    'Last Updated': new Date(b.lastUpdated).toLocaleDateString(),
                    'Created By': b.createdBy || 'N/A'
                }));
                const wsPending = XLSX.utils.json_to_sheet(pendingData);
                XLSX.utils.book_append_sheet(workbook, wsPending, 'Pending Batches');
                
                // === FINISHED BATCHES SHEET ===
                const finishedData = finishedBatches.map(b => ({
                    'Batch ID': b.id,
                    'Colour': b.colour,
                    'Material': b.material,
                    'Total Weight (kg)': b.totalWeight,
                    'Entries': b.entries.length,
                    'Finished': new Date(b.finishedAt || b.lastUpdated).toLocaleDateString(),
                    'Last Updated': new Date(b.lastUpdated).toLocaleDateString(),
                    'Updated By': b.updatedBy || 'N/A'
                }));
                const wsFinished = XLSX.utils.json_to_sheet(finishedData);
                XLSX.utils.book_append_sheet(workbook, wsFinished, 'Finished Batches');
                
                // === ENTRIES SHEET (unchanged, includes status column) ===
                if (appState.entries.length > 0) {
                    const entriesData = appState.entries.map(entry => ({
                        'Entry ID': entry.id,
                        'Material': entry.material,
                        'Colour': entry.colour,
                        'Weight (kg)': entry.weight,
                        'Status': entry.status.charAt(0).toUpperCase() + entry.status.slice(1),
                        'Date': new Date(entry.timestamp).toLocaleDateString(),
                        'Time': new Date(entry.timestamp).toLocaleTimeString(),
                        'Added By': entry.addedBy || 'N/A'
                    }));
                    const wsEntries = XLSX.utils.json_to_sheet(entriesData);
                    XLSX.utils.book_append_sheet(workbook, wsEntries, 'Entries');
                }
            }
            
            if (type === 'summary' || type === 'details') {
                // === SUMMARY SHEET with separate totals ===
                const summaryData = [
                    { 'Metric': 'Pending Batches', 'Count': pendingBatches.length, 'Weight (kg)': pendingBatches.reduce((s,b)=>s+b.totalWeight,0).toFixed(1) },
                    { 'Metric': 'Finished Batches', 'Count': finishedBatches.length, 'Weight (kg)': finishedBatches.reduce((s,b)=>s+b.totalWeight,0).toFixed(1) },
                    { 'Metric': 'Total Batches', 'Count': appState.batches.length, 'Weight (kg)': (appState.batches.reduce((s,b)=>s+b.totalWeight,0)).toFixed(1) },
                    { 'Metric': 'Total Entries', 'Count': appState.entries.length, 'Weight (kg)': '' }
                ];
                const wsSummary = XLSX.utils.json_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(workbook, wsSummary, 'Summary');
                
                // === MATERIAL SUMMARY (still includes both) ===
                const materialSummary = {};
                appState.batches.forEach(batch => {
                    if (!materialSummary[batch.material]) {
                        materialSummary[batch.material] = { pending: 0, finished: 0 };
                    }
                    if (batch.status === 'pending') {
                        materialSummary[batch.material].pending += batch.totalWeight;
                    } else {
                        materialSummary[batch.material].finished += batch.totalWeight;
                    }
                });
                const materialData = Object.keys(materialSummary).map(m => ({
                    'Material': m,
                    'Pending (kg)': materialSummary[m].pending.toFixed(1),
                    'Finished (kg)': materialSummary[m].finished.toFixed(1),
                    'Total (kg)': (materialSummary[m].pending + materialSummary[m].finished).toFixed(1)
                }));
                const wsMaterial = XLSX.utils.json_to_sheet(materialData);
                XLSX.utils.book_append_sheet(workbook, wsMaterial, 'Material Summary');
            }
            
            XLSX.writeFile(workbook, `Haji_Ali_Traders_Export_${new Date().toISOString().split('T')[0]}.xlsx`);
            showNotification(`‚úÖ Excel file exported successfully`);
        }
        
        function exportSummaryReport() {
            exportToPDF('summary');
        }
        
        function exportDetailedReport() {
            exportToExcel('details');
        }
        
        // ============================================
        // AUTHENTICATION FUNCTIONS (unchanged)
        // ============================================
        function showLoginModal() {
            if (elements.loginModal) {
                openModal(elements.loginModal);
                if (elements.mobileNumber) {
                    elements.mobileNumber.focus();
                    elements.mobileNumber.value = '';
                }
            }
        }
        
        function loginWithMobile() {
            if (!elements.mobileNumber) return;
            const mobile = elements.mobileNumber.value.trim();
            if (!mobile || mobile.length !== 10 || !/^\d+$/.test(mobile)) {
                showNotification("Please enter a valid 10-digit mobile number", "error");
                return;
            }
            if (mobile !== APP_CONFIG.authorizedMobile) {
                showNotification("Access denied. This mobile number is not authorized.", "error");
                return;
            }
            appState.isLoggedIn = true;
            appState.user = { mobile, loggedInAt: new Date().toISOString() };
            localStorage.setItem('wastesort_auth', JSON.stringify(appState.user));
            updateLoginUI();
            if (elements.loginModal) closeModal(elements.loginModal);
            setEditMode(true);
            showNotification(`‚úÖ Logged in successfully`);
        }
        
        function logout() {
            if (confirm("Are you sure you want to logout?")) {
                appState.isLoggedIn = false;
                appState.user = null;
                localStorage.removeItem('wastesort_auth');
                updateLoginUI();
                setEditMode(false);
                showNotification("Logged out successfully");
            }
        }
        
        function updateLoginUI() {
            if (appState.isLoggedIn && elements.loginStatus && elements.loginBtn && elements.viewOnlyMessage) {
                elements.loginStatus.style.display = 'flex';
                if (elements.userMobile) elements.userMobile.textContent = appState.user.mobile;
                elements.loginBtn.style.display = 'none';
                elements.viewOnlyMessage.style.display = 'none';
            } else {
                if (elements.loginStatus) elements.loginStatus.style.display = 'none';
                if (elements.loginBtn) elements.loginBtn.style.display = 'flex';
                if (elements.viewOnlyMessage) elements.viewOnlyMessage.style.display = 'block';
            }
        }
        
        function setEditMode(enabled) {
            const editElements = [
                elements.saveBtn, elements.clearBtn, elements.addMaterialBtn, elements.addColourBtn,
                elements.clearAllBtn, elements.importBtn, elements.clearPendingBtn, elements.clearFinishedBtn,
                elements.weightInput
            ];
            editElements.forEach(el => {
                if (el) enabled ? el.classList.remove('disabled-for-view') : el.classList.add('disabled-for-view');
            });
            document.querySelectorAll('.btn-edit, .btn-finish, .btn-move, .status-btn, .grid-btn').forEach(btn => {
                if (enabled) btn.classList.remove('disabled-for-view');
                else btn.classList.add('disabled-for-view');
            });
        }
        
        function checkAuthState() {
            const savedAuth = localStorage.getItem('wastesort_auth');
            if (savedAuth) {
                try {
                    const authData = JSON.parse(savedAuth);
                    appState.isLoggedIn = true;
                    appState.user = authData;
                    updateLoginUI();
                    setEditMode(true);
                } catch (error) {
                    console.error("Error parsing auth data:", error);
                    appState.isLoggedIn = false;
                    setEditMode(false);
                }
            } else {
                appState.isLoggedIn = false;
                setEditMode(false);
            }
        }
        
        // ============================================
        // FIREBASE INITIALIZATION (unchanged)
        // ============================================
        async function initializeFirebase() {
            try {
                if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                    console.warn("Firebase config not set. Running in offline mode.");
                    showNotification("Running in offline mode. Configure Firebase for cloud sync.", "error");
                    return false;
                }
                firebase.initializeApp(firebaseConfig);
                appState.db = firebase.firestore();
                await appState.db.enablePersistence().catch((err) => {
                    console.warn("Offline persistence failed:", err);
                });
                appState.firebaseInitialized = true;
                console.log("Firebase initialized successfully");
                setupFirebaseListeners();
                return true;
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showNotification("Firebase connection failed. Running offline.", "error");
                return false;
            }
        }
        
        function setupFirebaseListeners() {
            if (!appState.firebaseInitialized) return;
            const materialsUnsubscribe = appState.db.collection(APP_CONFIG.firestoreCollections.materials)
                .onSnapshot((snapshot) => {
                    const firebaseMaterials = [];
                    snapshot.forEach(doc => firebaseMaterials.push(doc.data().name));
                    const allMaterials = [...APP_CONFIG.defaultMaterials];
                    firebaseMaterials.forEach(mat => { if (!allMaterials.includes(mat)) allMaterials.push(mat); });
                    appState.materials = allMaterials;
                    renderMaterialGrid();
                });
            const coloursUnsubscribe = appState.db.collection(APP_CONFIG.firestoreCollections.colours)
                .onSnapshot((snapshot) => {
                    const firebaseColours = [];
                    snapshot.forEach(doc => firebaseColours.push(doc.data().name));
                    const allColours = [...APP_CONFIG.defaultColours];
                    firebaseColours.forEach(col => { if (!allColours.includes(col)) allColours.push(col); });
                    appState.colours = allColours;
                    renderColourGrid();
                });
            const batchesUnsubscribe = appState.db.collection(APP_CONFIG.firestoreCollections.batches)
    .orderBy('lastUpdated', 'desc')
    .onSnapshot((snapshot) => {
        // If we're temporarily ignoring snapshots (after clearing), do nothing
        if (appState._ignoreBatchSnapshot) return;

        const batches = [];
        snapshot.forEach(doc => batches.push({ id: doc.id, ...doc.data() }));
        appState.batches = batches;
        updateAllDisplays();
        updateSyncStatus(true);
    });
        
        // ============================================
        // HELPER FUNCTIONS (unchanged)
        // ============================================
        function generateBatchId(colour, material, status) {
            return `${colour.trim()}-${material.trim()}-${status}`.toLowerCase().replace(/\s+/g, '-');
        }
        
        function getOrCreateFinishedBatch(entry) {
            const targetId = generateBatchId(entry.colour, entry.material, 'finished');
            let finishedBatch = appState.batches.find(b => b.id === targetId && b.status === 'finished');
            if (!finishedBatch) {
                const legacyBatch = appState.batches.find(b => 
                    b.colour?.trim().toLowerCase() === entry.colour.trim().toLowerCase() &&
                    b.material?.trim().toLowerCase() === entry.material.trim().toLowerCase() &&
                    b.status === 'finished'
                );
                if (legacyBatch) {
                    finishedBatch = legacyBatch;
                    const oldId = finishedBatch.id;
                    finishedBatch.id = targetId;
                    if (appState.firebaseInitialized && appState.isOnline) {
                        appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(oldId).delete()
                            .then(() => saveBatchToFirebase(finishedBatch)).catch(console.error);
                    } else {
                        queueForSync({ type: 'batch_delete', id: oldId });
                        queueForSync({ type: 'batch_update', data: finishedBatch });
                    }
                }
            }
            if (!finishedBatch) {
                finishedBatch = {
                    id: targetId,
                    material: entry.material,
                    colour: entry.colour,
                    entries: [],
                    totalWeight: 0,
                    status: 'finished',
                    createdAt: new Date().toISOString(),
                    lastUpdated: new Date().toISOString(),
                    createdBy: entry.addedBy,
                    finishedAt: new Date().toISOString()
                };
                appState.batches.push(finishedBatch);
            }
            return finishedBatch;
        }
        
        // ============================================
        // DATA MANAGEMENT FUNCTIONS
        // ============================================
        async function saveEntry() {
            if (!appState.isLoggedIn) {
                showNotification("Please login to add entries", "error");
                showLoginModal();
                return;
            }
            if (!appState.selectedMaterial) {
                showNotification("Please select a material", "error");
                return;
            }
            if (!appState.selectedColour) {
                showNotification("Please select a colour", "error");
                return;
            }
            const weight = parseFloat(elements.weightInput?.value);
            if (!weight || weight <= 0 || isNaN(weight)) {
                showNotification("Please enter a valid weight", "error");
                if (elements.weightInput) elements.weightInput.focus();
                return;
            }
            try {
                const entry = {
                    id: Date.now().toString(),
                    material: appState.selectedMaterial,
                    colour: appState.selectedColour,
                    weight: parseFloat(weight.toFixed(2)),
                    status: appState.selectedStatus,
                    timestamp: new Date().toISOString(),
                    deviceId: getDeviceId(),
                    addedBy: appState.user.mobile
                };
                saveToLocalStorage(entry);
                
                if (entry.status === 'pending') {
                    const batchId = generateBatchId(entry.colour, entry.material, 'pending');
                    let batch = appState.batches.find(b => b.id === batchId);
                    if (!batch) {
                        batch = {
                            id: batchId,
                            material: entry.material,
                            colour: entry.colour,
                            entries: [entry],
                            totalWeight: entry.weight,
                            status: 'pending',
                            createdAt: new Date().toISOString(),
                            lastUpdated: new Date().toISOString(),
                            createdBy: appState.user.mobile
                        };
                        appState.batches.push(batch);
                    } else {
                        batch.entries.push(entry);
                        batch.totalWeight = parseFloat((batch.totalWeight + entry.weight).toFixed(2));
                        batch.lastUpdated = new Date().toISOString();
                        batch.updatedBy = appState.user.mobile;
                    }
                    if (appState.firebaseInitialized && appState.isOnline) {
                        await saveBatchToFirebase(batch);
                    } else {
                        queueForSync({ type: 'batch_update', data: batch });
                    }
                } else {
                    const finishedBatch = getOrCreateFinishedBatch(entry);
                    finishedBatch.entries.push(entry);
                    finishedBatch.totalWeight = parseFloat((finishedBatch.totalWeight + entry.weight).toFixed(2));
                    finishedBatch.lastUpdated = new Date().toISOString();
                    finishedBatch.updatedBy = appState.user.mobile;
                    finishedBatch.finishedAt = new Date().toISOString();
                    if (appState.firebaseInitialized && appState.isOnline) {
                        await saveBatchToFirebase(finishedBatch);
                    } else {
                        queueForSync({ type: 'batch_update', data: finishedBatch });
                    }
                }
                updateAllDisplays();
                showNotification(`‚úÖ ${entry.weight}kg ${entry.material} (${entry.colour}) saved as ${entry.status}`);
                clearForm();
            } catch (error) {
                console.error("Save error:", error);
                showNotification("Error saving entry", "error");
            }
        }
        
        async function saveBatchToFirebase(batch) {
            if (!appState.firebaseInitialized) return;
            try {
                await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(batch.id).set(batch);
            } catch (error) {
                console.error("Firebase save error:", error);
                throw error;
            }
        }
        
        async function addNewMaterial(materialName) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to add materials", "error");
                showLoginModal();
                return;
            }
            if (!materialName.trim()) {
                showNotification("Please enter a material name", "error");
                return;
            }
            materialName = materialName.trim();
            if (appState.materials.includes(materialName)) {
                showNotification("Material already exists", "error");
                return;
            }
            appState.materials.push(materialName);
            renderMaterialGrid();
            if (appState.firebaseInitialized) {
                try {
                    await appState.db.collection(APP_CONFIG.firestoreCollections.materials)
                        .doc(materialName.toLowerCase().replace(/\s+/g, '-'))
                        .set({ name: materialName, addedAt: new Date().toISOString(), addedBy: appState.user.mobile });
                    showNotification(`‚úÖ New material "${materialName}" added`);
                } catch (error) {
                    console.error("Error saving material to Firebase:", error);
                    showNotification("Material added locally", "error");
                }
            } else {
                showNotification(`‚úÖ New material "${materialName}" added locally`);
            }
            if (elements.materialModal) closeModal(elements.materialModal);
            selectMaterial(materialName);
        }
        
        async function addNewColour(colourName) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to add colours", "error");
                showLoginModal();
                return;
            }
            if (!colourName.trim()) {
                showNotification("Please enter a colour name", "error");
                return;
            }
            colourName = colourName.trim();
            if (appState.colours.includes(colourName)) {
                showNotification("Colour already exists", "error");
                return;
            }
            appState.colours.push(colourName);
            renderColourGrid();
            if (appState.firebaseInitialized) {
                try {
                    await appState.db.collection(APP_CONFIG.firestoreCollections.colours)
                        .doc(colourName.toLowerCase().replace(/\s+/g, '-'))
                        .set({ name: colourName, addedAt: new Date().toISOString(), addedBy: appState.user.mobile });
                    showNotification(`‚úÖ New colour "${colourName}" added`);
                } catch (error) {
                    console.error("Error saving colour to Firebase:", error);
                    showNotification("Colour added locally", "error");
                }
            } else {
                showNotification(`‚úÖ New colour "${colourName}" added locally`);
            }
            if (elements.colourModal) closeModal(elements.colourModal);
            selectColour(colourName);
        }
        
        async function updateBatchWeight(batchId, newWeight) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to edit weights", "error");
                showLoginModal();
                return;
            }
            const batch = appState.batches.find(b => b.id === batchId);
            if (!batch) return;
            const oldWeight = batch.totalWeight;
            batch.totalWeight = parseFloat(newWeight);
            batch.lastUpdated = new Date().toISOString();
            batch.updatedBy = appState.user.mobile;
            if (appState.firebaseInitialized && appState.isOnline) {
                try {
                    await saveBatchToFirebase(batch);
                    showNotification(`‚úÖ Batch weight updated from ${oldWeight}kg to ${newWeight}kg`);
                } catch (error) {
                    showNotification("Error updating weight in cloud", "error");
                }
            } else {
                queueForSync({ type: 'batch_update', data: batch });
                showNotification(`‚úÖ Weight updated locally (will sync when online)`);
            }
            updateAllDisplays();
            if (elements.editWeightModal) closeModal(elements.editWeightModal);
        }
        
        function openMoveWeightModal(batchId) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to move weight", "error");
                showLoginModal();
                return;
            }
            const batch = appState.batches.find(b => b.id === batchId);
            if (!batch) return;
            if (batch.status !== 'pending') {
                showNotification("Only pending batches can be moved", "error");
                return;
            }
            appState.movingBatch = batch;
            if (elements.moveBatchTitle) {
                elements.moveBatchTitle.textContent = `Move weight from ${batch.colour} ${batch.material} (max ${batch.totalWeight.toFixed(1)} kg)`;
            }
            if (elements.moveWeightInput) {
                elements.moveWeightInput.value = '';
                elements.moveWeightInput.max = batch.totalWeight;
                elements.moveWeightInput.step = 0.1;
                elements.moveWeightInput.min = 0.1;
            }
            openModal(elements.moveWeightModal);
        }
        
        async function moveBatchWeight() {
            if (!appState.isLoggedIn) {
                showNotification("Please login to move weight", "error");
                showLoginModal();
                return;
            }
            const pendingBatch = appState.movingBatch;
            if (!pendingBatch) return;
            const moveWeight = parseFloat(elements.moveWeightInput?.value);
            if (!moveWeight || moveWeight <= 0 || isNaN(moveWeight)) {
                showNotification("Please enter a valid weight to move", "error");
                if (elements.moveWeightInput) elements.moveWeightInput.focus();
                return;
            }
            if (moveWeight >= pendingBatch.totalWeight) {
                showNotification("Use 'Mark Finished' to move the entire batch", "error");
                return;
            }
            try {
                const movedEntry = {
                    id: Date.now().toString() + '-move',
                    material: pendingBatch.material,
                    colour: pendingBatch.colour,
                    weight: parseFloat(moveWeight.toFixed(2)),
                    status: 'finished',
                    timestamp: new Date().toISOString(),
                    deviceId: getDeviceId(),
                    addedBy: appState.user.mobile,
                    movedFrom: pendingBatch.id
                };
                const entries = JSON.parse(localStorage.getItem('wastesort_entries') || '[]');
                entries.push(movedEntry);
                localStorage.setItem('wastesort_entries', JSON.stringify(entries));
                appState.entries.push(movedEntry);
                
                const finishedBatch = getOrCreateFinishedBatch(movedEntry);
                finishedBatch.entries.push(movedEntry);
                finishedBatch.totalWeight = parseFloat((finishedBatch.totalWeight + moveWeight).toFixed(2));
                finishedBatch.lastUpdated = new Date().toISOString();
                finishedBatch.updatedBy = appState.user.mobile;
                finishedBatch.finishedAt = new Date().toISOString();
                
                pendingBatch.totalWeight = parseFloat((pendingBatch.totalWeight - moveWeight).toFixed(2));
                pendingBatch.lastUpdated = new Date().toISOString();
                pendingBatch.updatedBy = appState.user.mobile;
                
                if (appState.firebaseInitialized && appState.isOnline) {
                    try {
                        await saveBatchToFirebase(pendingBatch);
                        await saveBatchToFirebase(finishedBatch);
                        showNotification(`‚úÖ Moved ${moveWeight}kg to finished batch`);
                    } catch (error) {
                        console.error("Error moving batch in cloud:", error);
                        showNotification("Error updating cloud, changes saved locally", "error");
                    }
                } else {
                    queueForSync({ type: 'batch_update', data: pendingBatch });
                    queueForSync({ type: 'batch_update', data: finishedBatch });
                    showNotification(`‚úÖ Moved ${moveWeight}kg to finished batch (offline, will sync later)`);
                }
                updateAllDisplays();
                closeModal(elements.moveWeightModal);
                appState.movingBatch = null;
            } catch (error) {
                console.error("Move weight error:", error);
                showNotification("Error moving weight", "error");
            }
        }
        
        async function markBatchAsFinished(batchId) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to mark batches as finished", "error");
                showLoginModal();
                return;
            }
            const pendingBatch = appState.batches.find(b => b.id === batchId);
            if (!pendingBatch) return;
            if (pendingBatch.status !== 'pending') {
                showNotification("This batch is already finished", "error");
                return;
            }
            if (!confirm(`Mark ${pendingBatch.colour} ${pendingBatch.material} (${pendingBatch.totalWeight}kg) as finished?`)) return;
            
            const finishedBatchId = generateBatchId(pendingBatch.colour, pendingBatch.material, 'finished');
            let finishedBatch = appState.batches.find(b => b.id === finishedBatchId && b.status === 'finished');
            if (!finishedBatch) {
                finishedBatch = appState.batches.find(b => 
                    b.colour?.trim().toLowerCase() === pendingBatch.colour.trim().toLowerCase() &&
                    b.material?.trim().toLowerCase() === pendingBatch.material.trim().toLowerCase() &&
                    b.status === 'finished'
                );
                if (finishedBatch) {
                    const oldId = finishedBatch.id;
                    finishedBatch.id = finishedBatchId;
                    if (appState.firebaseInitialized && appState.isOnline) {
                        await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(oldId).delete().catch(console.error);
                        await saveBatchToFirebase(finishedBatch);
                    } else {
                        queueForSync({ type: 'batch_delete', id: oldId });
                        queueForSync({ type: 'batch_update', data: finishedBatch });
                    }
                }
            }
            
            if (finishedBatch) {
                finishedBatch.entries.push(...pendingBatch.entries);
                finishedBatch.totalWeight = parseFloat((finishedBatch.totalWeight + pendingBatch.totalWeight).toFixed(2));
                finishedBatch.lastUpdated = new Date().toISOString();
                finishedBatch.updatedBy = appState.user.mobile;
                finishedBatch.finishedAt = new Date().toISOString();
                
                appState.batches = appState.batches.filter(b => b.id !== pendingBatch.id);
                
                if (appState.firebaseInitialized && appState.isOnline) {
                    try {
                        await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(pendingBatch.id).delete();
                        await saveBatchToFirebase(finishedBatch);
                        showNotification(`‚úÖ Merged into existing finished batch ‚Äì total now ${finishedBatch.totalWeight.toFixed(1)}kg`);
                    } catch (error) {
                        console.error("Error merging batch in cloud:", error);
                        showNotification("Error updating cloud, changes saved locally", "error");
                    }
                } else {
                    queueForSync({ type: 'batch_delete', id: pendingBatch.id });
                    queueForSync({ type: 'batch_update', data: finishedBatch });
                    showNotification(`‚úÖ Merged into existing finished batch (offline, will sync later)`);
                }
            } else {
                const oldId = pendingBatch.id;
                pendingBatch.status = 'finished';
                pendingBatch.finishedAt = new Date().toISOString();
                pendingBatch.lastUpdated = new Date().toISOString();
                pendingBatch.finishedBy = appState.user.mobile;
                pendingBatch.id = finishedBatchId;
                
                appState.batches = appState.batches.filter(b => b.id !== oldId);
                appState.batches.push(pendingBatch);
                
                if (appState.firebaseInitialized && appState.isOnline) {
                    try {
                        await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(oldId).delete();
                        await saveBatchToFirebase(pendingBatch);
                        showNotification(`‚úÖ Batch marked as finished`);
                    } catch (error) {
                        console.error("Error updating batch in cloud:", error);
                        showNotification("Error updating cloud, changes saved locally", "error");
                    }
                } else {
                    queueForSync({ type: 'batch_delete', id: oldId });
                    queueForSync({ type: 'batch_update', data: pendingBatch });
                    showNotification(`‚úÖ Batch marked as finished locally`);
                }
            }
            updateAllDisplays();
        }
        
       async function clearPendingBatches() {
    if (!appState.isLoggedIn) {
        showNotification("Please login to clear pending batches", "error");
        showLoginModal();
        return;
    }
    const pendingBatches = appState.batches.filter(b => b.status === 'pending');
    if (pendingBatches.length === 0) {
        showNotification("No pending batches to clear", "error");
        return;
    }
    if (!confirm(`Are you sure you want to delete ALL ${pendingBatches.length} pending batches? This cannot be undone!`)) return;
    
    appState._ignoreBatchSnapshot = true;

    const pendingBatchIds = pendingBatches.map(b => b.id);
    
    appState.batches = appState.batches.filter(b => b.status !== 'pending');
    appState.entries = appState.entries.filter(entry => {
        if (entry.status !== 'pending') return true;
        const entryBatchId = generateBatchId(entry.colour, entry.material, 'pending');
        return !pendingBatchIds.includes(entryBatchId);
    });
    appState.pendingSync = appState.pendingSync.filter(item => 
        !(item.type === 'batch_update' && pendingBatchIds.includes(item.data.id)) &&
        !(item.type === 'batch_delete' && pendingBatchIds.includes(item.id))
    );
    
    localStorage.setItem('wastesort_batches', JSON.stringify(appState.batches));
    localStorage.setItem('wastesort_entries', JSON.stringify(appState.entries));
    localStorage.setItem('wastesort_pending_sync', JSON.stringify(appState.pendingSync));
    
    const failedDeletions = [];
    if (appState.firebaseInitialized) {
        const deletePromises = pendingBatchIds.map(async (id) => {
            try {
                await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(id).delete();
            } catch (error) {
                console.error(`Failed to delete ${id} from Firestore:`, error);
                failedDeletions.push(id);
            }
        });
        await Promise.allSettled(deletePromises);
    }
    
    if (failedDeletions.length > 0) {
        failedDeletions.forEach(id => {
            appState.pendingSync.push({ type: 'batch_delete', id, timestamp: new Date().toISOString() });
        });
        localStorage.setItem('wastesort_pending_sync', JSON.stringify(appState.pendingSync));
        showNotification(`‚ö†Ô∏è ${failedDeletions.length} batches cleared locally, but cloud deletion failed. Will retry.`, "error");
    } else {
        showNotification(`‚úÖ Cleared ${pendingBatchIds.length} pending batches`);
    }
    
    setTimeout(() => {
        appState._ignoreBatchSnapshot = false;
    }, 1000);
    
    updateAllDisplays();
}
        
      async function clearFinishedBatches() {
    if (!appState.isLoggedIn) {
        showNotification("Please login to clear finished batches", "error");
        showLoginModal();
        return;
    }
    const finishedBatches = appState.batches.filter(b => b.status === 'finished');
    if (finishedBatches.length === 0) {
        showNotification("No finished batches to clear", "error");
        return;
    }
    if (!confirm(`Are you sure you want to delete ALL ${finishedBatches.length} finished batches? This cannot be undone!`)) return;
    
    // Temporarily ignore Firestore snapshot updates
    appState._ignoreBatchSnapshot = true;

    const finishedBatchIds = finishedBatches.map(b => b.id);
    
    // 1. Update local state immediately
    appState.batches = appState.batches.filter(b => b.status !== 'finished');
    appState.entries = appState.entries.filter(entry => {
        if (entry.status !== 'finished') return true;
        const entryBatchId = generateBatchId(entry.colour, entry.material, 'finished');
        return !finishedBatchIds.includes(entryBatchId);
    });
    appState.pendingSync = appState.pendingSync.filter(item => 
        !(item.type === 'batch_update' && finishedBatchIds.includes(item.data.id)) &&
        !(item.type === 'batch_delete' && finishedBatchIds.includes(item.id))
    );
    
    // Save to localStorage
    localStorage.setItem('wastesort_batches', JSON.stringify(appState.batches));
    localStorage.setItem('wastesort_entries', JSON.stringify(appState.entries));
    localStorage.setItem('wastesort_pending_sync', JSON.stringify(appState.pendingSync));
    
    // 2. Attempt Firestore deletions
    const failedDeletions = [];
    if (appState.firebaseInitialized) {
        const deletePromises = finishedBatchIds.map(async (id) => {
            try {
                await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(id).delete();
            } catch (error) {
                console.error(`Failed to delete ${id} from Firestore:`, error);
                failedDeletions.push(id);
            }
        });
        await Promise.allSettled(deletePromises);
    }
    
    // 3. If some deletions failed, queue them for later sync
    if (failedDeletions.length > 0) {
        failedDeletions.forEach(id => {
            appState.pendingSync.push({ type: 'batch_delete', id, timestamp: new Date().toISOString() });
        });
        localStorage.setItem('wastesort_pending_sync', JSON.stringify(appState.pendingSync));
        showNotification(`‚ö†Ô∏è ${failedDeletions.length} batches cleared locally, but cloud deletion failed. Will retry.`, "error");
    } else {
        showNotification(`‚úÖ Cleared ${finishedBatchIds.length} finished batches`);
    }
    
    // 4. Re‚Äëenable snapshot listener after a short delay (so any pending cloud updates settle)
    setTimeout(() => {
        appState._ignoreBatchSnapshot = false;
        // Optionally trigger a manual refresh from Firestore
        if (appState.firebaseInitialized && appState.isOnline) {
            // Force a refresh by touching the listener? Not needed ‚Äì it will resume automatically.
        }
    }, 1000);
    
    updateAllDisplays();
}
        
        // ============================================
        // LOCAL STORAGE FUNCTIONS (unchanged)
        // ============================================
        function saveToLocalStorage(entry) {
            try {
                const entries = JSON.parse(localStorage.getItem('wastesort_entries') || '[]');
                entries.push(entry);
                localStorage.setItem('wastesort_entries', JSON.stringify(entries));
                localStorage.setItem('wastesort_batches', JSON.stringify(appState.batches));
                localStorage.setItem('wastesort_materials', JSON.stringify(appState.materials));
                localStorage.setItem('wastesort_colours', JSON.stringify(appState.colours));
            } catch (error) {
                console.error("LocalStorage error:", error);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const entries = JSON.parse(localStorage.getItem('wastesort_entries') || '[]');
                const batches = JSON.parse(localStorage.getItem('wastesort_batches') || '[]');
                const materials = JSON.parse(localStorage.getItem('wastesort_materials') || '[]');
                const colours = JSON.parse(localStorage.getItem('wastesort_colours') || '[]');
                
                if (entries.length > 0) appState.entries = entries;
                if (batches.length > 0) appState.batches = batches;
                if (materials.length > 0) appState.materials = [...new Set([...APP_CONFIG.defaultMaterials, ...materials])];
                if (colours.length > 0) appState.colours = [...new Set([...APP_CONFIG.defaultColours, ...colours])];
            } catch (error) {
                console.error("LocalStorage load error:", error);
            }
        }
        
        // ============================================
        // SYNC FUNCTIONS (unchanged)
        // ============================================
        function queueForSync(item) {
            appState.pendingSync.push({ ...item, timestamp: new Date().toISOString() });
            localStorage.setItem('wastesort_pending_sync', JSON.stringify(appState.pendingSync));
            updateSyncStatus(false);
        }
        
        async function processPendingSync() {
            if (!appState.firebaseInitialized || !appState.isOnline) return;
            if (appState.pendingSync.length === 0) return;
            try {
                for (const item of appState.pendingSync) {
                    if (item.type === 'batch_update') await saveBatchToFirebase(item.data);
                    else if (item.type === 'batch_delete') await appState.db.collection(APP_CONFIG.firestoreCollections.batches).doc(item.id).delete();
                }
                appState.pendingSync = [];
                localStorage.removeItem('wastesort_pending_sync');
                updateSyncStatus(true);
                showNotification("‚úÖ Pending changes synced to cloud");
            } catch (error) {
                console.error("Sync error:", error);
            }
        }
        
        function updateSyncStatus(synced) {
            if (elements.syncDot && elements.syncText) {
                if (synced) {
                    elements.syncDot.classList.remove('offline');
                    elements.syncText.textContent = 'Synced';
                    appState.lastSyncTime = new Date();
                } else {
                    elements.syncDot.classList.add('offline');
                    elements.syncText.textContent = 'Offline';
                    if (elements.syncStatus) elements.syncStatus.title = `${appState.pendingSync.length} pending changes`;
                }
            }
            if (elements.badges.add) {
                if (appState.pendingSync.length > 0) {
                    elements.badges.add.textContent = appState.pendingSync.length;
                    elements.badges.add.style.display = 'block';
                } else {
                    elements.badges.add.style.display = 'none';
                }
            }
            // Update backup sync time display
            updateBackupStats();
        }
        
        // ============================================
        // UI RENDERING FUNCTIONS
        // ============================================
        function renderMaterialGrid() {
            if (!elements.materialGrid) return;
            elements.materialGrid.innerHTML = '';
            appState.materials.forEach(material => {
                const button = document.createElement('button');
                button.className = 'grid-btn';
                if (appState.selectedMaterial === material) button.classList.add('selected');
                button.textContent = material;
                button.dataset.value = material;
                button.addEventListener('click', () => selectMaterial(material));
                elements.materialGrid.appendChild(button);
            });
        }
        
        function renderColourGrid() {
            if (!elements.colourGrid) return;
            elements.colourGrid.innerHTML = '';
            appState.colours.forEach(colour => {
                const button = document.createElement('button');
                button.className = 'grid-btn';
                if (appState.selectedColour === colour) button.classList.add('selected');
                button.textContent = colour;
                button.dataset.value = colour;
                button.addEventListener('click', () => selectColour(colour));
                elements.colourGrid.appendChild(button);
            });
        }
        
        function renderBatchList(listElement, batches) {
            if (!listElement) return;
            if (batches.length === 0) {
                listElement.innerHTML = `<div class="empty-state"><div class="empty-icon">üì≠</div><h3>No batches found</h3><p>Add entries to see them here</p></div>`;
                return;
            }
            let html = '';
            batches.forEach(batch => {
                const isPending = batch.status === 'pending';
                const date = new Date(batch.lastUpdated).toLocaleDateString();
                const time = new Date(batch.lastUpdated).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                let actionsHtml = '';
                if (isPending) {
                    actionsHtml = `
                        <button class="action-small btn-edit" onclick="openEditWeightModal('${batch.id}')">‚öñÔ∏è Edit Weight</button>
                        <button class="action-small btn-move" onclick="openMoveWeightModal('${batch.id}')">‚û°Ô∏è Move</button>
                        <button class="action-small btn-finish" onclick="markBatchAsFinished('${batch.id}')">‚úÖ Mark Finished</button>
                    `;
                } else {
                    actionsHtml = `<button class="action-small btn-edit" onclick="openEditWeightModal('${batch.id}')">‚öñÔ∏è Edit Weight</button>`;
                }
                html += `
                    <div class="batch-card ${batch.status}">
                        <div class="batch-header">
                            <div class="batch-title">
                                <span class="color-dot" style="background: ${getColorCode(batch.colour)}"></span>
                                ${batch.colour} ‚Ä¢ ${batch.material}
                            </div>
                            <div class="batch-weight">${batch.totalWeight.toFixed(1)} kg</div>
                        </div>
                        <div class="batch-details">
                            <span>${batch.entries.length} entries</span>
                            <span>Updated: ${date} ${time}</span>
                        </div>
                        <div class="batch-actions">${actionsHtml}</div>
                    </div>
                `;
            });
            listElement.innerHTML = html;
        }
        
        // NEW: Update Backup tab stats ‚Äì separate pending & finished
        function updateBackupStats() {
            if (!elements.pendingBackupStats || !elements.finishedBackupStats || !elements.totalBackupStats) return;
            
            const pendingBatches = appState.batches.filter(b => b.status === 'pending');
            const finishedBatches = appState.batches.filter(b => b.status === 'finished');
            const pendingWeight = pendingBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            const finishedWeight = finishedBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            
            elements.pendingBackupStats.textContent = `${pendingBatches.length} (${pendingWeight.toFixed(1)} kg)`;
            elements.finishedBackupStats.textContent = `${finishedBatches.length} (${finishedWeight.toFixed(1)} kg)`;
            
            const dataSize = JSON.stringify(appState).length;
            const kb = (dataSize / 1024).toFixed(1);
            const syncTime = appState.lastSyncTime ? formatTime(appState.lastSyncTime) : '-';
            elements.totalBackupStats.innerHTML = `${appState.entries.length}<br><span style="font-size:0.9rem;">${kb} KB | ${syncTime}</span>`;
        }
        
        function updateAllDisplays() {
            const pendingBatches = appState.batches.filter(b => b.status === 'pending');
            const finishedBatches = appState.batches.filter(b => b.status === 'finished');
            const pendingTotal = pendingBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            const finishedTotal = finishedBatches.reduce((sum, b) => sum + b.totalWeight, 0);
            const pendingEntries = pendingBatches.reduce((sum, b) => sum + b.entries.length, 0);
            const finishedEntries = finishedBatches.reduce((sum, b) => sum + b.entries.length, 0);
            
            if (elements.pendingTotalWeight) elements.pendingTotalWeight.textContent = pendingTotal.toFixed(1);
            if (elements.pendingBatchesCount) elements.pendingBatchesCount.textContent = pendingBatches.length;
            if (elements.pendingItemsCount) elements.pendingItemsCount.textContent = pendingEntries;
            if (elements.finishedTotalWeight) elements.finishedTotalWeight.textContent = finishedTotal.toFixed(1);
            if (elements.finishedBatchesCount) elements.finishedBatchesCount.textContent = finishedBatches.length;
            if (elements.finishedItemsCount) elements.finishedItemsCount.textContent = finishedEntries;
            
            if (elements.badges.pending) elements.badges.pending.textContent = pendingBatches.length;
            if (elements.badges.finished) elements.badges.finished.textContent = finishedBatches.length;
            
            renderBatchList(elements.pendingList, pendingBatches);
            renderBatchList(elements.finishedList, finishedBatches);
            
            updateBackupStats(); // new call
        }
        
        // ============================================
        // UI INTERACTION FUNCTIONS
        // ============================================
        function selectMaterial(material) {
            appState.selectedMaterial = material;
            renderMaterialGrid();
        }
        
        function selectColour(colour) {
            appState.selectedColour = colour;
            renderColourGrid();
        }
        
        function clearForm() {
            appState.selectedMaterial = null;
            appState.selectedColour = null;
            if (elements.weightInput) elements.weightInput.value = '';
            renderMaterialGrid();
            renderColourGrid();
            if (elements.statusButtons) {
                elements.statusButtons.forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.dataset.status === 'pending') {
                        btn.classList.add('selected');
                        appState.selectedStatus = 'pending';
                    }
                });
            }
        }
        
        function openModal(modal) {
            if (!modal) return;
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            if (modal === elements.materialModal && elements.newMaterialInput) elements.newMaterialInput.focus();
            else if (modal === elements.colourModal && elements.newColourInput) elements.newColourInput.focus();
            else if (modal === elements.editWeightModal && elements.editWeightInput) elements.editWeightInput.focus();
            else if (modal === elements.moveWeightModal && elements.moveWeightInput) elements.moveWeightInput.focus();
            else if (modal === elements.loginModal && elements.mobileNumber) elements.mobileNumber.focus();
        }
        
        function closeModal(modal) {
            if (!modal) return;
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
            if (elements.newMaterialInput) elements.newMaterialInput.value = '';
            if (elements.newColourInput) elements.newColourInput.value = '';
            if (elements.editWeightInput) elements.editWeightInput.value = '';
            if (elements.moveWeightInput) elements.moveWeightInput.value = '';
            appState.editingBatch = null;
            appState.movingBatch = null;
        }
        
        function openEditWeightModal(batchId) {
            if (!appState.isLoggedIn) {
                showNotification("Please login to edit weights", "error");
                showLoginModal();
                return;
            }
            const batch = appState.batches.find(b => b.id === batchId);
            if (!batch) return;
            appState.editingBatch = batch;
            if (elements.editBatchTitle) elements.editBatchTitle.textContent = `Edit weight for ${batch.colour} ${batch.material}`;
            if (elements.editWeightInput) elements.editWeightInput.value = batch.totalWeight;
            openModal(elements.editWeightModal);
        }
        
        function showNotification(message, type = 'success') {
            if (!elements.notification || !elements.notificationText) return;
            elements.notificationText.textContent = message;
            elements.notification.className = 'notification';
            if (type === 'error') elements.notification.classList.add('error');
            elements.notification.style.display = 'block';
            setTimeout(() => { if (elements.notification) elements.notification.style.display = 'none'; }, 3000);
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function getDeviceId() {
            let deviceId = localStorage.getItem('wastesort_device_id');
            if (!deviceId) {
                deviceId = 'device-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('wastesort_device_id', deviceId);
            }
            return deviceId;
        }
        
        function getColorCode(colour) {
            const colorMap = {
                'red': '#e74c3c', 'orange': '#e67e22', 'yellow': '#f1c40f', 'green': '#2ecc71',
                'white': '#ecf0f1', 'grey': '#95a5a6', 'black': '#2c3e50', 'blue': '#3498db',
                'purple': '#9b59b6', 'pink': '#e84393', 'brown': '#8B4513', 'maroon': '#800000',
                'teal': '#1abc9c', 'navy': '#2c3e50', 'olive': '#808000', 'lime': '#00ff00',
                'cyan': '#00ffff', 'magenta': '#ff00ff'
            };
            const lowerColour = colour.toLowerCase();
            for (const [key, value] of Object.entries(colorMap)) {
                if (lowerColour.includes(key)) return value;
            }
            let hash = 0;
            for (let i = 0; i < colour.length; i++) hash = colour.charCodeAt(i) + ((hash << 5) - hash);
            const hue = hash % 360;
            return `hsl(${hue}, 70%, 60%)`;
        }
        
        function formatTime(date) {
            if (!date) return '-';
            return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }
        
        // ============================================
        // MIGRATION FUNCTION (unchanged)
        // ============================================
        async function migrateBatchIds() {
            console.log("Running comprehensive data migration...");
            let migrated = false;
            const localBatches = JSON.parse(localStorage.getItem('wastesort_batches') || '[]');
            const updatedLocalBatches = localBatches.map(batch => {
                let changed = false;
                if (!batch.status) {
                    const batchEntries = appState.entries.filter(e => 
                        e.colour?.trim().toLowerCase() === batch.colour?.trim().toLowerCase() &&
                        e.material?.trim().toLowerCase() === batch.material?.trim().toLowerCase()
                    );
                    const hasFinishedEntry = batchEntries.some(e => e.status === 'finished');
                    batch.status = hasFinishedEntry ? 'finished' : 'pending';
                    changed = true;
                }
                const oldId = batch.id;
                if (!oldId.endsWith('-pending') && !oldId.endsWith('-finished')) {
                    const newId = generateBatchId(batch.colour, batch.material, batch.status);
                    batch.id = newId;
                    changed = true;
                    migrated = true;
                    console.log(`Migrated batch: ${oldId} ‚Üí ${newId} (status: ${batch.status})`);
                }
                return changed ? batch : batch;
            });
            if (migrated) {
                localStorage.setItem('wastesort_batches', JSON.stringify(updatedLocalBatches));
                appState.batches = updatedLocalBatches;
                console.log("‚úÖ localStorage batches migrated and statuses corrected");
            }
            if (appState.firebaseInitialized && appState.isOnline) {
                const batchesRef = appState.db.collection(APP_CONFIG.firestoreCollections.batches);
                const snapshot = await batchesRef.get();
                for (const doc of snapshot.docs) {
                    const oldId = doc.id;
                    const data = doc.data();
                    if (oldId.endsWith('-pending') || oldId.endsWith('-finished')) continue;
                    let status = data.status;
                    if (!status) status = 'pending';
                    const newId = generateBatchId(data.colour, data.material, status);
                    data.status = status;
                    data.id = newId;
                    await batchesRef.doc(newId).set(data);
                    await batchesRef.doc(oldId).delete();
                    migrated = true;
                    console.log(`Migrated Firestore doc: ${oldId} ‚Üí ${newId}`);
                }
            }
            if (migrated) showNotification("üîÑ Data format upgraded ‚Äì batch IDs now include status", "success");
        }
        
        // ============================================
        // EVENT LISTENERS SETUP
        // ============================================
        function setupEventListeners() {
            if (elements.tabs) {
                elements.tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;
                        elements.tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        elements.tabContents.forEach(content => {
                            content.classList.remove('active');
                            if (content.id === tabId) content.classList.add('active');
                        });
                    });
                });
            }
            if (elements.statusButtons) {
                elements.statusButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        elements.statusButtons.forEach(b => b.classList.remove('selected'));
                        this.classList.add('selected');
                        appState.selectedStatus = this.dataset.status;
                    });
                });
            }
            if (elements.addMaterialBtn) elements.addMaterialBtn.addEventListener('click', () => openModal(elements.materialModal));
            if (elements.addColourBtn) elements.addColourBtn.addEventListener('click', () => openModal(elements.colourModal));
            if (elements.clearBtn) elements.clearBtn.addEventListener('click', clearForm);
            if (elements.saveBtn) elements.saveBtn.addEventListener('click', saveEntry);
            
            if (elements.exportPdfBtn) elements.exportPdfBtn.addEventListener('click', () => exportToPDF('summary'));
            if (elements.exportExcelBtn) elements.exportExcelBtn.addEventListener('click', () => exportToExcel('full'));
            if (elements.exportSummaryBtn) elements.exportSummaryBtn.addEventListener('click', exportSummaryReport);
            if (elements.exportDetailsBtn) elements.exportDetailsBtn.addEventListener('click', exportDetailedReport);
            
            if (elements.exportBtn) {
                elements.exportBtn.addEventListener('click', () => {
                    const data = { app: APP_CONFIG.appName, version: APP_CONFIG.version, exportedAt: new Date().toISOString(), batches: appState.batches, entries: appState.entries, materials: appState.materials, colours: appState.colours };
                    const dataStr = JSON.stringify(data, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `haji-ali-traders-backup-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    showNotification('‚úÖ JSON backup exported successfully');
                });
            }
            
            if (elements.importBtn) {
                elements.importBtn.addEventListener('click', () => {
                    if (!appState.isLoggedIn) {
                        showNotification("Please login to import data", "error");
                        showLoginModal();
                        return;
                    }
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        try {
                            const text = await file.text();
                            const data = JSON.parse(text);
                            if (confirm(`Import ${data.batches?.length || 0} batches? This will replace current data.`)) {
                                appState.batches = data.batches || [];
                                appState.entries = data.entries || [];
                                appState.materials = data.materials || APP_CONFIG.defaultMaterials;
                                appState.colours = data.colours || APP_CONFIG.defaultColours;
                                localStorage.setItem('wastesort_batches', JSON.stringify(appState.batches));
                                localStorage.setItem('wastesort_entries', JSON.stringify(appState.entries));
                                localStorage.setItem('wastesort_materials', JSON.stringify(appState.materials));
                                localStorage.setItem('wastesort_colours', JSON.stringify(appState.colours));
                                updateAllDisplays();
                                showNotification(`‚úÖ ${data.batches?.length || 0} batches imported`);
                            }
                        } catch (error) {
                            showNotification('Invalid backup file', 'error');
                        }
                    };
                    input.click();
                });
            }
            
            if (elements.clearAllBtn) {
                elements.clearAllBtn.addEventListener('click', () => {
                    if (!appState.isLoggedIn) {
                        showNotification("Please login to clear data", "error");
                        showLoginModal();
                        return;
                    }
                    if (confirm('Delete ALL data? This cannot be undone!')) {
                        localStorage.clear();
                        appState.batches = [];
                        appState.entries = [];
                        appState.materials = [...APP_CONFIG.defaultMaterials];
                        appState.colours = [...APP_CONFIG.defaultColours];
                        appState.pendingSync = [];
                        updateAllDisplays();
                        clearForm();
                        showNotification('‚úÖ All data cleared');
                    }
                });
            }
            
            if (elements.clearPendingBtn) elements.clearPendingBtn.addEventListener('click', clearPendingBatches);
            if (elements.clearFinishedBtn) elements.clearFinishedBtn.addEventListener('click', clearFinishedBatches);
            
            if (elements.saveMaterialBtn) elements.saveMaterialBtn.addEventListener('click', () => addNewMaterial(elements.newMaterialInput?.value || ''));
            if (elements.cancelMaterialBtn) elements.cancelMaterialBtn.addEventListener('click', () => closeModal(elements.materialModal));
            if (elements.saveColourBtn) elements.saveColourBtn.addEventListener('click', () => addNewColour(elements.newColourInput?.value || ''));
            if (elements.cancelColourBtn) elements.cancelColourBtn.addEventListener('click', () => closeModal(elements.colourModal));
            if (elements.saveEditBtn) elements.saveEditBtn.addEventListener('click', () => { if (appState.editingBatch) updateBatchWeight(appState.editingBatch.id, elements.editWeightInput?.value); });
            if (elements.cancelEditBtn) elements.cancelEditBtn.addEventListener('click', () => closeModal(elements.editWeightModal));
            if (elements.saveMoveBtn) elements.saveMoveBtn.addEventListener('click', moveBatchWeight);
            if (elements.cancelMoveBtn) elements.cancelMoveBtn.addEventListener('click', () => closeModal(elements.moveWeightModal));
            
            if (elements.loginBtn) elements.loginBtn.addEventListener('click', showLoginModal);
            if (elements.logoutBtn) elements.logoutBtn.addEventListener('click', logout);
            if (elements.loginMobileBtn) elements.loginMobileBtn.addEventListener('click', loginWithMobile);
            if (elements.cancelLoginBtn) elements.cancelLoginBtn.addEventListener('click', () => closeModal(elements.loginModal));
            
            if (elements.mobileNumber) {
                elements.mobileNumber.addEventListener('input', function() { this.value = this.value.replace(/\D/g, '').slice(0, 10); });
                elements.mobileNumber.addEventListener('keypress', function(e) { if (e.key === 'Enter') loginWithMobile(); });
            }
            
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(modal); });
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeModal(elements.materialModal); closeModal(elements.colourModal);
                    closeModal(elements.editWeightModal); closeModal(elements.moveWeightModal);
                    closeModal(elements.loginModal);
                }
                if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); saveEntry(); }
            });
            
            window.addEventListener('online', () => { appState.isOnline = true; updateSyncStatus(true); processPendingSync(); });
            window.addEventListener('offline', () => { appState.isOnline = false; updateSyncStatus(false); });
            setInterval(() => { if (appState.isOnline && appState.pendingSync.length > 0) processPendingSync(); }, 30000);
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        async function initializeApp() {
            loadFromLocalStorage();
            checkAuthState();
            await initializeFirebase();
            await migrateBatchIds();
            renderMaterialGrid();
            renderColourGrid();
            updateAllDisplays();
            setupEventListeners();
            updateSyncStatus(appState.isOnline && appState.pendingSync.length === 0);
            console.log("App initialized successfully");
            if (!appState.isLoggedIn) showNotification("üîí You're in view-only mode. Login to edit data.", "error");
            else showNotification(`Welcome back, ${appState.user.mobile}!`, "success");
        }
        
        window.openEditWeightModal = openEditWeightModal;
        window.openMoveWeightModal = openMoveWeightModal;
        window.markBatchAsFinished = markBatchAsFinished;
        window.showLoginModal = showLoginModal;
        window.exportToPDF = exportToPDF;
        window.exportToExcel = exportToExcel;
        
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>